package com.jimnelson372.aoc2023.day22;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Day22Part2 {

    record Position(
            long x,
            long y,
            long z) implements Comparable<Position> {

        @Override
        public int compareTo(Position o) {
            return Comparator.comparing(Position::z)
                    .thenComparing(Position::x)
                    .thenComparing(Position::y)
                    .compare(this, o);
        }

        Position dropDistance(long distZ) {
            return new Position(x, y, z - distZ);
        }
    }

    record Range(
            long low,
            long high) {
        boolean overlaps(Range other) {
            return (other.low >= low && other.low <= high)
                    || (other.high >= low && other.high <= high)
                    || (this.low >= other.low && this.low <= other.high)
                    || (this.high >= other.low && this.high <= other.high);
        }
    }

    record Relation(
            long supported,
            long supporter) {
    }

    static class Brick implements Comparable<Brick> {

        private static long idGen = 0;

        // These are public.
        final public long id;  // autogenerated, simple counter.
        final public Position lower;
        final public Position higher;

        // These are internal.
        final private Range lowXRange;
        final private Range highXRange;
        final private Range lowYRange;
        final private Range highYRange;

        // Public constructor.
        public Brick(Position lower, Position higher) {
            this.id = ++idGen;
            this.lower = lower;
            this.higher = higher;
            if (lower.z == higher.z) {
                this.lowXRange = new Range(Math.min(lower.x, higher.x), Math.max(lower.x, higher.x));
                this.lowYRange = new Range(Math.min(lower.y, higher.y), Math.max(lower.y, higher.y));
                this.highXRange = this.lowXRange;
                this.highYRange = this.lowYRange;
            } else {
                this.lowXRange = new Range(lower.x, lower.x);
                this.lowYRange = new Range(lower.y, lower.y);
                this.highXRange = new Range(higher.x, higher.x);
                this.highYRange = new Range(higher.y, higher.y);
            }
        }

        // Internal constructor.
        private Brick(long id,
                      Range lowXRange,
                      Range highXRange,
                      Range lowYRange,
                      Range highYRange,
                      Position lower,
                      Position higher) {
            this.id = id;
            this.lowXRange = lowXRange;
            this.highXRange = highXRange;
            this.lowYRange = lowYRange;
            this.highYRange = highYRange;
            this.lower = lower;
            this.higher = higher;
        }

        @Override
        public int compareTo(Brick o) {
            return Comparator.comparing(Brick::getLower)
                    .thenComparing(Brick::getHigher)
                    .compare(this, o);
        }

        public Position getLower() {
            return lower;
        }

        public Position getHigher() {
            return higher;
        }

        @Override
        public String toString() {
            return "Brick{" +
                    "id=" + id +
                    ", lower=" + lower +
                    ", higher=" + higher +
                    '}';
        }

        public boolean isUnderneath(Brick other) {
            return other.lowYRange.overlaps(this.highYRange)
                    && other.lowXRange.overlaps(this.highXRange);

        }

        public Brick dropDistance(long distZ) {
            return new Brick(this.id,
                             this.lowXRange,
                             this.highXRange,
                             this.lowYRange,
                             this.highYRange,
                             this.lower.dropDistance(distZ),
                             this.higher.dropDistance(distZ));
        }
    }

    public static void main(String[] args) {
        var startTime = System.nanoTime();
        String resourcesPath = Paths.get("src", "main", "resources")
                .toString();
        try (BufferedReader br = Files.newBufferedReader(Paths.get(resourcesPath, "day22-puzzle-input.txt"))) {
            var bricks = getBricks(br);

            List<Relation> brickRelations = new ArrayList<>();
            List<Brick> droppedBrickList = new ArrayList<>();

            // drop all the bricks to their support level, also start gathering relationships among bricks.
            dropBricksAndRecordAllRelation(bricks, brickRelations, droppedBrickList);

            // Query the brickRelations table to form useful grouping information.
            //  used in both Part 1 and Part2.
            var supportedBricksPerBrick = brickRelations.stream()
                    .collect(Collectors.groupingBy(Relation::supporter,
                                                   Collectors.mapping(Relation::supported,
                                                                      Collectors.toSet())));
            var numSupportBricksPerBrick = brickRelations.stream()
                    .collect(Collectors.groupingBy(Relation::supported, Collectors.counting()));

            var supportBricksPerBrick = brickRelations.stream()
                    .collect(Collectors.groupingBy(Relation::supported,
                                                   Collectors.mapping(Relation::supporter,
                                                                      Collectors.toSet())));

            long howManySafeToRemove = solvePart1(droppedBrickList, supportedBricksPerBrick, numSupportBricksPerBrick);
            System.out.println("Solution to Part 1: " + howManySafeToRemove);

            var sumOfFallsEveryBrickCouldCause =
                    solvePart2(droppedBrickList, supportedBricksPerBrick, supportBricksPerBrick);
            System.out.println("Solution to Part 2: " + sumOfFallsEveryBrickCouldCause);

        } catch (IOException e) {
            System.out.print("The puzzle input was not found at expected location.");
        }
        System.out.println("---------------");
        System.out.println("Completed In: " + (System.nanoTime() - startTime) / 1_000_000 + "ms");
    }

    private static List<Brick> getBricks(BufferedReader br) {
        return br.lines()
                .map(l -> l.split("~"))
                .map(l2 -> {
                    var positions = Arrays.stream(l2)
                            .map(rawPos -> {
                                var pos = Arrays.stream(rawPos.split(","))
                                        .map(Long::valueOf)
                                        .toList();
                                return new Position(pos.get(0), pos.get(1), pos.get(2));
                            })
                            .sorted()
                            .toList();
                    return new Brick(positions.get(0), positions.get(1));
                })
                .sorted()
                .toList();
    }

    private static void dropBricksAndRecordAllRelation(List<Brick> bricks,
                                                       List<Relation> relation,
                                                       List<Brick> brickList) {
        HashSet<Brick> dropped = new HashSet<>();
        brickList.addAll(IntStream.range(0, bricks.size())
                                 .sequential()
                                 .boxed()
                                 .map(i -> {
                                     var brick = bricks.get(i);
                                     if (brick.lower.z == 1) {
                                         dropped.add(brick);
                                         return brick;
                                     } else {
                                         var brickToDropOnto = dropped.stream()
                                                 // To lower/drop the current brick, we have to find the set of bricks
                                                 // whose tops are highest below the current brick.

                                                 // So we filter for only those whose top is below it and that
                                                 //  it come to rest on.
                                                 .filter(b -> b.higher.z < brick.lower.z)
                                                 .filter(b2 -> b2.isUnderneath(brick))

                                                 // Then we group all that qualify by their Z positions,
                                                 //  sort them and find the top set.
                                                 .collect(Collectors.groupingBy(b -> b.getHigher().z))
                                                 .entrySet()
                                                 .stream()
                                                 .sorted(Map.Entry.<Long, List<Brick>>comparingByKey()
                                                                 .reversed())
                                                 .map(Map.Entry::getValue)
                                                 .findFirst();

                                         // And then if we have bricks to drop down to, we do.
                                         // otherwise we drop all the way to z=1.
                                         Brick newlyDroppedBrick;
                                         if (brickToDropOnto.isPresent()) {
                                             var identifiedSupportBrick = brickToDropOnto.get();

                                             var dropToZPosition = identifiedSupportBrick.get(0).higher.z + 1;
                                             newlyDroppedBrick = brick.dropDistance(brick.lower.z - dropToZPosition);

                                             recordOneRelation(identifiedSupportBrick, relation, newlyDroppedBrick);
                                         } else {
                                             newlyDroppedBrick = brick.dropDistance(brick.lower.z - 1);
                                         }
                                         dropped.add(newlyDroppedBrick);
                                         return newlyDroppedBrick;
                                     }
                                 })
                                 .toList());
    }

    private static long solvePart1(List<Brick> bricks,
                                   Map<Long, Set<Long>> supportedBricksPerBrick,
                                   Map<Long, Long> numSupportBricksPerBrick) {
        // Once we have all the organized data, the actual calculation is easy.

        // the count of those that support nothing.
        long count = bricks.size() - supportedBricksPerBrick.size();

        // For each supporter brick, checks if all the bricks it supports  have more than 1
        //  supporter.  If true, none will fall if this brick is removed.
        count += supportedBricksPerBrick.values()
                .stream()
                .filter(v -> v.stream()
                        .allMatch(r -> numSupportBricksPerBrick.get(r) > 1L))
                .count();
        return count;
    }

    private static Long solvePart2(List<Brick> bricks,
                                   Map<Long, Set<Long>> supportedBricksPerBrick,
                                   Map<Long, Set<Long>> supportBricksPerBrick) {
        // For each brick, lookup those that are resting on it, and for those who
        //  are resting only on already removed or fallen bricks, add them to
        //  the set to evaluate further, looping so long as there are more
        //  bricks falling.
        return bricks.stream()
                .map(brick -> {
                         // These Sets are local to the processing of the currrent brick.
                         Set<Long> bricksToEvaluate = new HashSet<>(Set.of(brick.id));
                         Set<Long> removedAndFallenBricks = new HashSet<>(Set.of(brick.id));

                         // Recursive logic, though using flatMap to generate a set of
                         //  of falling bricks to evaluate further.
                         while (!bricksToEvaluate.isEmpty()) {
                             bricksToEvaluate = bricksToEvaluate.stream()
                                     .flatMap(fallingBrick -> {
                                         var testForNextToFall = supportedBricksPerBrick
                                                 .getOrDefault(fallingBrick,
                                                               Set.of());
                                         return testForNextToFall.stream()
                                                 // If all the bricks it is resting on are gone, it
                                                 // will fall.
                                                 .filter(n -> removedAndFallenBricks
                                                         .containsAll(supportBricksPerBrick.getOrDefault(n, Set.of())));
                                     })
                                     .collect(Collectors.toSet());
                             var nextToFall = bricksToEvaluate;
                             removedAndFallenBricks.addAll(nextToFall);
                         }
                         return removedAndFallenBricks.size() - 1L; // sub 1 as brick doesn't count its own removal
                     }
                    )
                   .reduce(0L, Long::sum);
    }

    private static void recordOneRelation(List<Brick> supportBrick, List<Relation> relation, Brick newlyDroppedBrick) {
        supportBrick.forEach(supporter ->
                                     relation.add(new Relation(newlyDroppedBrick.id,
                                                               supporter.id)));
    }


}
